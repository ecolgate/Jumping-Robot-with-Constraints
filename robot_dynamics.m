%% robot_dynamics.m
%
% Description:
%   Computes the constraint forces: 
%       F = inv(A*Minv*A')*(A*Minv*(Q-H) + Adotqdot)
%
%   Also computes the derivative of the state:
%       x_dot(1:5) = (I - A'*inv(A*A')*A)*x(6:10)
%       x_dot(6:10) = inv(M)*(Q - H - A'F)
%
% Inputs:
%   t: time (scalar)
%   x: the 10x1 state vector, x = [x_cart; theta_pend; dx_cart; dtheta_pend];
%   u: control input (scalar, horizontal force applied to the cart)
%   params: a struct with many elements, generated by calling init_params.m
%
% Outputs:
%   dx: derivative of state x with respect to time.

function [dx] = robot_dynamics(t,x,variables,params)

% for convenience, define q and q_dot
dx = zeros(numel(x),1);
nq = numel(x)/2;    % assume that x = [q;q_dot];
q = x(1:nq);
q_dot = x(nq+1:2*nq);

% solve for control inputs at this instant
tau_s = interp1(variables.motor.spine.time,variables.motor.spine.torque,t);
tau_m = interp1(variables.motor.body.time,variables.motor.body.torque,t);
Q = [0;0;0;tau_s;tau_m];

% find the parts that don't depend on constraint forces
H = H_eom(x,params);
M = mass_matrix(x,params);
Minv = inv_mass_matrix(x,params);

% build the constraints, forces, and solve for acceleration 
nc = variables.foot.constraints(1) + 2*variables.foot.constraints(2);  % number of active contacts
% TODO: [F, A] = constraint_forces(t,x,variables,params);
switch nc  
    case 0      % both feet are off the ground
        constraint_term = zeros(nq,1); % no constraints active
        proj_mat = eye(nq); % not really a projection matrix for this case
    case 1      % left foot is on the ground and right is off
        [A_all,Hessian] = constraint_derivatives(x,params);
        A = A_all([1,2],:);
        Adotqdot = [q_dot'*Hessian(:,:,1)*q_dot;
                    q_dot'*Hessian(:,:,2)*q_dot ];
        F = inv(A*Minv*A')*(A*Minv*(Q - H) + Adotqdot);
        constraint_term = A'*F;
        proj_mat = eye(nq) - A'*inv(A*A')*A;
    case 2      % right foot is on the ground and left is off
        [A_all,Hessian] = constraint_derivatives(x,params);
        A = A_all([3,4],:);
        Adotqdot = [q_dot'*Hessian(:,:,3)*q_dot;
                    q_dot'*Hessian(:,:,4)*q_dot ];
        F = inv(A*Minv*A')*(A*Minv*(Q - H) + Adotqdot);
        constraint_term = A'*F;
        proj_mat = eye(nq) - A'*inv(A*A')*A;
    case 3      % both feet are on the ground
        [A_all,Hessian] = constraint_derivatives(x,params);
        A = A_all([1,2,4],:);
        Adotqdot = [q_dot'*Hessian(:,:,1)*q_dot;
                    q_dot'*Hessian(:,:,2)*q_dot;
                    q_dot'*Hessian(:,:,4)*q_dot ];
        F = inv(A*Minv*A')*(A*Minv*(Q - H) + Adotqdot);
        constraint_term = A'*F;
        proj_mat = eye(nq) - A'*inv(A*A')*A;
end

dx(1:nq) = proj_mat*q_dot;
dx(nq+1:2*nq) = Minv*(Q - H - constraint_term);

end