%% main.m
%
% Description:
%   Application entry point.
%
% Inputs: none
%
% Outputs: none
%
% Notes:

function main

%% Initialize environment
clear;
close all;
clc;

init_env();

%% Initialize parameters
params = init_params;

%% Set up events using odeset
options = odeset('Events',@robot_events);

%% Simulate the robot forward in time 
x_IC = params.x_IC';    % initial conditions
tnow = 0.0;             % starting time

% start with null matrices for holding results -- we'll be adding to these
% with each segment of the simulation
tsim = [];
xsim = [];
F_list = [];

% create a place for events
events = [];

% the main loop
while tnow < params.sim.tfinal

    tspan = [tnow params.sim.tfinal];
    [tseg, xseg, ~, ~, ie] = ode45(@robot_dynamics, tspan, x_IC, options);

    % augment tsim and xsim; renew ICs
    tsim = [tsim;tseg];
    xsim = [xsim;xseg];
    tnow = tsim(end);
    x_IC = xsim(end,:); 
    
    % compute the constraint forces that were active during the jump
    Fseg = zeros(4,length(tseg));
    for i=1:length(tseg)
        [~,Fseg(:,i)] = robot_dynamics(tseg(i),xseg(i,:)');
    end
    F_list = [F_list,Fseg];
    
    % if simulation terminated before tfinal, update the constraints and, if necessary, the velocities
    if tseg(end) < params.sim.tfinal  % termination was triggered by an event
        [x_IC] = change_constraints(x_IC,ie);
    end
    
end

%%  Plot Results %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Begin with plot of ground reaction versus weight, to be sure we're
% pushing off and then leaving the ground
figure;
plot(tsim,F_list(3,:)+F_list(4,:),'b-','LineWidth',2);
hold on
weight = (params.model.dyn.foot.m+params.model.dyn.spine.m+params.model.dyn.body.m)*params.model.dyn.g*ones(1,length(tsim));
plot(tsim,weight,'r-','LineWidth',1);
ylabel('Ground Reaction vs Weight (N)')
xlabel('time (sec)')
hold off

%% Animate Results %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Let's resample the simulator output so we can animate with evenly-spaced 
% points in (time,state). 
% 1) deal with possible duplicatetimes in tsim: 
% (https://www.mathworks.com/matlabcentral/answers/321603-how-do-i-interpolate-1d-data-if-i-do-not-have-unique-values
tsim = cumsum(ones(size(tsim)))*eps + tsim;

% 2) resample the duplicate-free time vector: 
t_anim = 0:params.viz.dt:tsim(end);

% 3) resample the state-vs-time array: 
x_anim = interp1(tsim,xsim,t_anim); x_anim = x_anim';  % transpose so that xsim is 10xN (N = number of timesteps)

% 4) resample the constraint forces-vs-time array: 
F_anim = interp1(tsim,F_list',t_anim); F_anim = F_anim';

% xsim = xsim';
% animate_robot(xsim(1:5,:),F_list(1:4,:),params,'trace_foot_com',true,...
%     'trace_body_com',true,'trace_spine_tip',true,'show_constraint_forces',true,'video',true);
animate_robot(x_anim(1:5,:),F_anim,params,'trace_foot_com',true,...
    'trace_body_com',true,'trace_spine_tip',true,'show_constraint_forces',true,'video',true);
fprintf('Done!\n');

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% end of main.m, except for nested functions






%% BELOW HERE ARE THE NESTED FUNCTIONS, ROBOT_DYNAMICS, ROBOT_EVENTS, AND CHANGE_CONSTRAINTS
%% THEY HAVE ACCESS TO ALL VARIABLES IN MAIN

%% robot_dynamics.m %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
% Description:
%   Computes the constraint forces: 
%       Fnow = inv(A*Minv*A')*(A*Minv*(Q-H) + Adotqdot)
%
%   Also computes the derivative of the state:
%       x_dot(1:5) = (I - A'*inv(A*A')*A)*x(6:10)
%       x_dot(6:10) = inv(M)*(Q - H - A'F)
%
% Inputs:
%   t: time (scalar)
%   x: the 10x1 state vector
%   params: a struct with many elements, generated by calling init_params.m
%
% Outputs:
%   dx: derivative of state x with respect to time.
%   F:  6x1 vector of constraint forces

function [dx,F] = robot_dynamics(~,x)

dx = zeros(numel(x),1);
nq = numel(x)/2-1;    % assume that x = [q;q_dot;sl;sr];
% for convenience, define q_dot and s
q_dot = x(nq+1:2*nq);
s = x(2*nq+1:2*nq+2);

% if both feet are on ground and body hasn't hit top, then apply max torque
if params.sim.constraints.active(1) && params.sim.constraints.active(2) && ~params.sim.constraints.active(3)
    Q = [0;0;0;0;.5*params.motor.body.peaktorque];
else  % otherwise, apply no torque at all
    Q = zeros(5,1);
end

% find the parts that don't depend on constraint forces
H = H_eom(x,params);
Minv = inv_mass_matrix(x,params);
[A,Hessian] = constraint_derivatives(x,params);

% solve for constraint forces, if any; compute velocities and accelerations
F = zeros(4,1);
n_active_constraints = sum(params.sim.constraints.active);  % number of active constraints

if n_active_constraints == 0  % if there are no constraints active, then there are no forces
    
    dx(1:nq) = q_dot;
    dx(nq+1:2*nq) = Minv*(Q - H);
    
else  % if there are constraints active, we must compute the constraint forces
    A = A(params.sim.constraints.active,:);   % eliminate inactive rows
    Hessian_active = Hessian(:,:,params.sim.constraints.active);  % eliminate inactive hessians
    Adotqdot = zeros(n_active_constraints,1);
    for ic=1:n_active_constraints
        Adotqdot(ic) = q_dot'*Hessian_active(:,:,ic)*q_dot;
    end
    
    % compute the constraint forces and accelerations
    F_active = (A*Minv*A')\(A*Minv*(Q - H) + Adotqdot);   % these are the constraint forces
    dx(1:nq) = (eye(nq) - A'*((A*A')\A))*x(nq+1:2*nq);
    dx(nq+1:2*nq) = Minv*(Q - H - A'*F_active);
        
end

% compute the pathlength derivatives for constraint tracking
[r_l,r_r] = foot_coordinates(x,params)
[v_l,v_r] = foot_velocities(x,params);
[p_l,t_l,~] = track(s(1),params);
[p_r,t_r,~] = track(s(2),params);

dx(2*nq+1) = [v_l + params.sim.constraints.gain*(r_l - p_l)]'*t_l;
dx(2*nq+2) = [v_r + params.sim.constraints.gain*(r_r - p_r)]'*t_r;

% 4x1 vector of constraint forces
F(params.sim.constraints.active) = F_active;   
% events:  forces for active constraints, distances for inactive constraints
C = constraints(x,params);
events = F;
events(~params.sim.constraints.active) = -C(~params.sim.constraints.active);

end
%% end of robot_dynamics.m %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


%% Event function for ODE45 %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Description:
%   Event function that is called when a constraint becomes active or inactive
%
% Inputs:
%   t and x are required, but not used
%   events is shared with parent function
%
% Outputs:
%   value
%   isterminal
%   direction
function [value,isterminal,direction] = robot_events(~,~)

   value = events;
   isterminal = ones(4,1);
   direction = -ones(4,1);

end
%% end of robot_events.m %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


%% Function to handle changing constraints %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% change_constraints.m
%
% Description:
%   function to handle changes in constraints, depending on the current
%   status of params.sim.constraints as well as ie, the index of the last
%   event to occur
%
% Inputs:
%   x_IC: the current state of the robot, which will be the initial
%   conditions for the next segment of integration
%   ie: the index of events returned by robot_events.m
%
% Outputs:
%   x_IC: the current state of the robot, which might be updated if the
%   event that occurred was a collision

function [x_IC] = change_constraints(x_IC,ie)

A = [];
restitution = [];
collision = 0;

for i1 = 1:length(ie)  % I'm not sure if ie is ever a vector ... just being sure!
    if params.sim.constraints.active(ie(i1))  % if the event came from an active constraint
        params.sim.constraints.active(ie(i1)) = 0; % then make the constraint inactive
    else    % the event came from an inactive constraint --> collision
        collision = 1;
        params.sim.constraints.active(ie(i1)) = 1; % make the constraint active
        % find the constraint jacobian
        [A_unilateral,~] = constraint_derivatives(x_IC,params);
        A = [A;A_unilateral(ie(i1),:)];
        restitution = [restitution,1+params.sim.constraints.restitution(ie(i1))];
    end
end

if collision == 1
    Minv = inv_mass_matrix(x_IC,params);
    % compute the change in velocity due to collision impulses
    x_IC(6:10) = x_IC(6:10) - (Minv*A'*inv(A*Minv*A')*diag(restitution)*A*x_IC(6:10)')';
    % Often in a collision, the constraint forces will be violated
    % immediately, rendering event detection useless since it requires a
    % smoothly changing variable.  Therefore, we need to check the
    % constraint forces and turn them off if they act in the wrong
    % direction
    [~,F] = robot_dynamics(0,x_IC');
    for i1=1:4
        if F(i1)<0, params.sim.constraints.active(i1) = 0; end  % turn off unilateral constraints with negative forces
    end
end

end
%% end of change_constraints.m %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

end
%% End of main.m %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%